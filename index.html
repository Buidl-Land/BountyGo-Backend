<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BountyGo Multi-Agent Test Page</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8fafc;
            color: #1f2937;
            line-height: 1.6;
        }

        /* Layout */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .container {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (min-width: 1024px) {
            .container {
                grid-template-columns: repeat(2, 1fr);
                gap: 24px;
            }
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            color: #2563eb;
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .header p {
            color: #6b7280;
            font-size: 1rem;
        }

        /* Section styles */
        .section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .section h2 {
            color: #1f2937;
            font-size: 1.25rem;
            margin-bottom: 8px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 8px;
        }

        .section.full-width {
            grid-column: 1 / -1;
        }

        /* Form elements */
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-group label {
            font-weight: 500;
            color: #374151;
            font-size: 0.875rem;
        }

        .input {
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .input.error {
            border-color: #ef4444;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
        }

        /* Field error messages */
        .field-error {
            color: #ef4444;
            font-size: 0.75rem;
            margin-top: 4px;
            display: block;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-4px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Enhanced error states */
        .input.error:focus {
            border-color: #ef4444;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
        }

        /* Global error overlay */
        .error-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10001;
        }

        .error-dialog {
            background: white;
            padding: 24px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        .error-dialog h3 {
            color: #ef4444;
            margin-bottom: 16px;
            font-size: 1.25rem;
        }

        .error-dialog p {
            margin-bottom: 16px;
            line-height: 1.6;
        }

        .error-dialog .error-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Network status indicator */
        .network-status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .network-status.online {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .network-status.offline {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }

        .network-status.slow {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fde68a;
        }

        .textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: #2563eb;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #1d4ed8;
        }

        .btn-secondary {
            background-color: #6b7280;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #4b5563;
        }

        .btn-success {
            background-color: #10b981;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background-color: #059669;
        }

        .btn-danger {
            background-color: #ef4444;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background-color: #dc2626;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.875rem;
        }

        /* Cards */
        .card {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 16px;
        }

        .card-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #374151;
        }

        .card-content {
            color: #6b7280;
            font-size: 0.875rem;
        }

        /* Results display */
        .results {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 16px;
            max-height: 300px;
            overflow-y: auto;
        }

        .results pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875rem;
        }

        /* Messages */
        .message {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 0.875rem;
        }

        .message-success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .message-error {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }

        .message-warning {
            background-color: #fef3c7;
            color: #92400e;
            border: 1px solid #fde68a;
        }

        .message-info {
            background-color: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }

        /* Loading spinner */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* File upload */
        .file-upload {
            border: 2px dashed #d1d5db;
            border-radius: 6px;
            padding: 24px;
            text-align: center;
            transition: border-color 0.2s;
            cursor: pointer;
        }

        .file-upload:hover {
            border-color: #2563eb;
        }

        .file-upload.dragover {
            border-color: #2563eb;
            background-color: #eff6ff;
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .file-preview {
            margin-top: 16px;
            text-align: center;
        }

        .file-preview img {
            max-width: 100%;
            max-height: 200px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Chat interface */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 400px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px 6px 0 0;
        }

        .chat-message {
            margin-bottom: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            max-width: 80%;
        }

        .chat-message.user {
            background: #2563eb;
            color: white;
            margin-left: auto;
        }

        .chat-message.assistant {
            background: white;
            border: 1px solid #e5e7eb;
        }

        .chat-input-container {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-top: none;
            border-radius: 0 0 6px 6px;
        }

        .chat-input {
            flex: 1;
        }

        /* Suggestions */
        .suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }

        .suggestion-btn {
            padding: 6px 12px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 16px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .suggestion-btn:hover {
            background: #e5e7eb;
        }

        /* Status indicator */
        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .status-online {
            background: #d1fae5;
            color: #065f46;
        }

        .status-offline {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-loading {
            background: #fef3c7;
            color: #92400e;
        }

        /* Loading states */
        .loading-state {
            opacity: 0.6;
            pointer-events: none;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Enhanced UI animations and effects */
        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        .btn {
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .form-group.focused .input {
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .formatted-result {
            font-family: inherit;
        }

        .formatted-result .result-item {
            margin-bottom: 12px;
            padding: 8px;
            background: #f9fafb;
            border-radius: 4px;
        }

        .formatted-result .result-item strong {
            color: #374151;
        }

        .formatted-result .text-content {
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .copy-btn {
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .results:hover .copy-btn {
            opacity: 1;
        }

        /* Toast animations */
        .toast {
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Enhanced focus states */
        .input:focus,
        .textarea:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        /* Button hover effects */
        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .btn:active:not(:disabled) {
            transform: translateY(1px);
        }

        /* Progress bar */
        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 2px;
            background: #2563eb;
            transition: width 0.3s ease;
        }

        /* Enhanced results display */
        .results {
            position: relative;
        }

        .results pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Utility classes */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .text-small {
            font-size: 0.875rem;
        }

        .text-muted {
            color: #6b7280;
        }

        .mb-2 {
            margin-bottom: 8px;
        }

        .mb-4 {
            margin-bottom: 16px;
        }

        .mt-2 {
            margin-top: 8px;
        }

        .mt-4 {
            margin-top: 16px;
        }

        /* Responsive adjustments */
        @media (max-width: 767px) {
            .container {
                padding: 12px;
                gap: 16px;
            }

            .section {
                padding: 16px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.875rem;
            }

            .chat-container {
                height: 300px;
            }

            .chat-message {
                max-width: 90%;
            }
        }

        /* Dark mode support (optional) */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #111827;
                color: #f9fafb;
            }

            .section,
            .header {
                background: #1f2937;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }

            .input,
            .textarea {
                background: #374151;
                border-color: #4b5563;
                color: #f9fafb;
            }

            .card,
            .results,
            .chat-messages {
                background: #374151;
                border-color: #4b5563;
            }

            .chat-message.assistant {
                background: #374151;
                border-color: #4b5563;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>BountyGo Multi-Agent Test Page</h1>
            <p>测试multi-agent系统和图片上传解析功能的简单前端界面</p>
        </header>

        <!-- Authentication Section -->
        <section class="section full-width">
            <h2>认证管理</h2>
            <div class="form-group">
                <label for="token-input">API Token</label>
                <input type="password" id="token-input" class="input" placeholder="输入API Token或留空使用开发环境token">
            </div>
            <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                <button id="save-token-btn" class="btn btn-primary">保存Token</button>
                <button id="get-dev-token-btn" class="btn btn-secondary">获取开发Token</button>
                <button id="clear-token-btn" class="btn btn-danger">清除Token</button>
            </div>
            <div id="auth-status" class="status status-offline">
                <span>●</span>
                <span>未认证</span>
            </div>
        </section>

        <!-- Multi-Agent Text Processing -->
        <section class="section">
            <h2>文本处理测试</h2>
            <div class="form-group">
                <label for="text-input">输入文本内容</label>
                <textarea id="text-input" class="input textarea" placeholder="输入要处理的文本内容..."></textarea>
            </div>
            <div class="form-group">
                <label for="context-input">上下文 (可选)</label>
                <input type="text" id="context-input" class="input" placeholder="输入上下文信息...">
            </div>
            <button id="process-text-btn" class="btn btn-primary">
                <span>处理文本</span>
            </button>
            <div id="text-results" class="results hidden">
                <pre id="text-results-content"></pre>
            </div>
        </section>

        <!-- Chat Interface -->
        <section class="section">
            <h2>智能聊天测试</h2>
            <div class="chat-container">
                <div id="chat-messages" class="chat-messages">
                    <div class="text-center text-muted">开始对话...</div>
                </div>
                <div class="chat-input-container">
                    <input type="text" id="chat-input" class="input chat-input" placeholder="输入消息...">
                    <button id="send-chat-btn" class="btn btn-primary">发送</button>
                </div>
            </div>
            <div id="chat-suggestions" class="suggestions"></div>
            <div style="margin-top: 12px;">
                <button id="clear-chat-btn" class="btn btn-secondary btn-small">清除对话</button>
            </div>
        </section>

        <!-- Image Upload Section -->
        <section class="section">
            <h2>图片上传分析</h2>
            <div class="file-upload" id="image-upload">
                <input type="file" id="image-input" accept="image/*">
                <div>
                    <p>点击选择图片或拖拽图片到此处</p>
                    <p class="text-small text-muted">支持 JPEG, PNG, GIF, WebP 格式，最大 10MB</p>
                </div>
            </div>
            <div id="image-preview" class="file-preview hidden"></div>
            <div class="form-group">
                <label for="image-prompt">分析提示 (可选)</label>
                <input type="text" id="image-prompt" class="input" placeholder="输入分析提示...">
            </div>
            <div class="form-group">
                <label for="image-context">上下文 (可选)</label>
                <input type="text" id="image-context" class="input" placeholder="输入上下文信息...">
            </div>
            <button id="analyze-image-btn" class="btn btn-primary" disabled>
                <span>分析图片</span>
            </button>
            <div id="image-results" class="results hidden">
                <pre id="image-results-content"></pre>
            </div>
        </section>

        <!-- URL Analysis Section -->
        <section class="section">
            <h2>URL分析测试</h2>
            <div class="form-group">
                <label for="url-input">URL链接</label>
                <input type="url" id="url-input" class="input" placeholder="输入要分析的URL...">
            </div>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="create-task-checkbox">
                    创建任务
                </label>
            </div>
            <button id="analyze-url-btn" class="btn btn-primary">
                <span>分析URL</span>
            </button>
            <div id="url-results" class="results hidden">
                <pre id="url-results-content"></pre>
            </div>
        </section>

        <!-- Status and Messages -->
        <section class="section full-width">
            <h2>状态信息</h2>
            <div id="messages-container">
                <div class="message message-info">
                    页面已加载，请先设置API Token或获取开发环境Token
                </div>
            </div>

            <!-- Error Statistics (Development Only) -->
            <div id="error-stats" class="hidden" style="margin-top: 16px;">
                <h3 style="font-size: 1rem; margin-bottom: 8px;">错误统计 (开发模式)</h3>
                <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                    <button id="show-error-stats-btn" class="btn btn-small btn-secondary">查看错误统计</button>
                    <button id="clear-error-log-btn" class="btn btn-small btn-secondary">清除错误日志</button>
                    <button id="export-error-log-btn" class="btn btn-small btn-secondary">导出错误日志</button>
                    <button id="test-error-btn" class="btn btn-small btn-danger">测试错误处理</button>
                </div>
            </div>
        </section>

        <!-- Network Status Indicator -->
        <div id="network-status" class="network-status online">
            <span>●</span>
            <span>网络正常</span>
        </div>
    </div>

    <script>
        // Authentication Manager Class
        class AuthManager {
            constructor() {
                this.tokenKey = 'bountygo_api_token';
                this.devTokenEndpoint = '/api/v1/dev-auth';
                this.validateEndpoint = '/api/v1/auth/me';
                this.currentToken = null;
                this.isAuthenticated = false;

                // Set base URL for API requests
                this.baseURL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
                    ? 'http://127.0.0.1:8003'    // Local backend server
                    : window.location.origin;    // Same origin for production

                this.init();
            }

            init() {
                // Load token from localStorage on initialization
                this.loadToken();
                this.updateAuthStatus();
                this.bindEvents();
            }

            bindEvents() {
                const saveTokenBtn = document.getElementById('save-token-btn');
                const getDevTokenBtn = document.getElementById('get-dev-token-btn');
                const clearTokenBtn = document.getElementById('clear-token-btn');
                const tokenInput = document.getElementById('token-input');

                if (saveTokenBtn) {
                    saveTokenBtn.addEventListener('click', () => this.saveToken());
                }

                if (getDevTokenBtn) {
                    getDevTokenBtn.addEventListener('click', () => this.getDevToken());
                }

                if (clearTokenBtn) {
                    clearTokenBtn.addEventListener('click', () => this.clearToken());
                }

                if (tokenInput) {
                    tokenInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.saveToken();
                        }
                    });
                }
            }

            loadToken() {
                try {
                    const storedToken = localStorage.getItem(this.tokenKey);
                    if (storedToken) {
                        this.currentToken = storedToken;
                        this.validateToken(storedToken);
                    }
                } catch (error) {
                    console.error('Error loading token from localStorage:', error);
                    this.showMessage('加载token时出错', 'error');
                }
            }

            async saveToken() {
                const tokenInput = document.getElementById('token-input');
                const token = tokenInput.value.trim();

                if (!token) {
                    this.showMessage('请输入有效的token', 'warning');
                    return;
                }

                try {
                    this.showMessage('验证token中...', 'info');
                    this.updateAuthStatus('loading');

                    const isValid = await this.validateToken(token);

                    if (isValid) {
                        localStorage.setItem(this.tokenKey, token);
                        this.currentToken = token;
                        this.isAuthenticated = true;
                        this.updateAuthStatus('authenticated');
                        this.showMessage('Token保存成功', 'success');
                        tokenInput.value = '';
                    } else {
                        this.showMessage('Token验证失败，请检查token是否正确', 'error');
                        this.updateAuthStatus('unauthenticated');
                    }
                } catch (error) {
                    console.error('Error saving token:', error);
                    this.showMessage('保存token时出错: ' + error.message, 'error');
                    this.updateAuthStatus('unauthenticated');
                }
            }

            async getDevToken() {
                try {
                    this.showMessage('获取开发环境token中...', 'info');
                    this.updateAuthStatus('loading');

                    const fullUrl = `${this.baseURL}${this.devTokenEndpoint}`;
                    console.log('Requesting dev token from:', fullUrl);

                    const response = await fetch(fullUrl, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.test_token) {
                        // 直接使用返回的测试token
                        const testToken = data.test_token;

                        // 验证token是否有效
                        const isValid = await this.validateToken(testToken);

                        if (isValid) {
                            localStorage.setItem(this.tokenKey, testToken);
                            this.currentToken = testToken;
                            this.isAuthenticated = true;
                            this.updateAuthStatus('authenticated');
                            this.showMessage('开发环境token获取成功', 'success');
                        } else {
                            throw new Error('开发token验证失败');
                        }
                    } else {
                        throw new Error('响应中未找到test_token');
                    }
                } catch (error) {
                    console.error('Error getting dev token:', error);
                    this.showMessage('获取开发环境token失败: ' + error.message, 'error');
                    this.updateAuthStatus('unauthenticated');
                }
            }

            clearToken() {
                try {
                    localStorage.removeItem(this.tokenKey);
                    this.currentToken = null;
                    this.isAuthenticated = false;
                    this.updateAuthStatus('unauthenticated');
                    this.showMessage('Token已清除', 'info');

                    // Clear token input field
                    const tokenInput = document.getElementById('token-input');
                    if (tokenInput) {
                        tokenInput.value = '';
                    }
                } catch (error) {
                    console.error('Error clearing token:', error);
                    this.showMessage('清除token时出错', 'error');
                }
            }

            async validateToken(token) {
                try {
                    const fullUrl = `${this.baseURL}${this.validateEndpoint}`;
                    console.log('Validating token at:', fullUrl);

                    const response = await fetch(fullUrl, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        // 如果能成功获取用户信息，说明token有效
                        const data = await response.json();
                        return data && data.id; // 检查是否有用户ID
                    } else if (response.status === 401) {
                        return false;
                    } else {
                        throw new Error(`验证请求失败: ${response.status}`);
                    }
                } catch (error) {
                    console.error('Token validation error:', error);
                    // For development, assume token is valid if validation endpoint is not available
                    if (error.message.includes('fetch')) {
                        console.warn('Token validation endpoint not available, assuming valid for development');
                        return true;
                    }
                    throw error;
                }
            }

            updateAuthStatus(status = null) {
                const authStatus = document.getElementById('auth-status');
                if (!authStatus) return;

                let statusClass, statusText;

                if (status === 'loading') {
                    statusClass = 'status-loading';
                    statusText = '验证中...';
                } else if (this.isAuthenticated || status === 'authenticated') {
                    statusClass = 'status-online';
                    statusText = '已认证';
                } else {
                    statusClass = 'status-offline';
                    statusText = '未认证';
                }

                authStatus.className = `status ${statusClass}`;
                authStatus.innerHTML = `<span>●</span><span>${statusText}</span>`;
            }

            getToken() {
                return this.currentToken;
            }

            isTokenValid() {
                return this.isAuthenticated && this.currentToken;
            }

            getAuthHeaders() {
                if (this.isTokenValid()) {
                    return {
                        'Authorization': `Bearer ${this.currentToken}`,
                        'Content-Type': 'application/json'
                    };
                }
                return {
                    'Content-Type': 'application/json'
                };
            }

            showMessage(message, type = 'info') {
                const messagesContainer = document.getElementById('messages-container');
                if (!messagesContainer) return;

                // Remove existing messages of the same type
                const existingMessages = messagesContainer.querySelectorAll(`.message-${type}`);
                existingMessages.forEach(msg => msg.remove());

                const messageDiv = document.createElement('div');
                messageDiv.className = `message message-${type}`;
                messageDiv.textContent = message;

                messagesContainer.appendChild(messageDiv);

                // Auto-remove success and info messages after 5 seconds
                if (type === 'success' || type === 'info') {
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 5000);
                }
            }
        }

        // API Client Class
        class APIClient {
            constructor(authManager) {
                this.authManager = authManager;
                // Use local backend server
                this.baseURL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
                    ? 'http://127.0.0.1:8003'    // Local backend server
                    : window.location.origin;    // Same origin for production
                this.defaultTimeout = 30000; // 30 seconds
                this.maxRetries = 3;
                this.retryDelay = 1000; // 1 second
                this.loadingStates = new Map();
            }

            async request(endpoint, options = {}) {
                const {
                    method = 'GET',
                    body = null,
                    headers = {},
                    timeout = this.defaultTimeout,
                    retries = this.maxRetries,
                    showLoading = true,
                    loadingTarget = null
                } = options;

                const url = `${this.baseURL}${endpoint}`;
                const requestId = `${method}-${endpoint}`;

                try {
                    if (showLoading) {
                        this.setLoadingState(loadingTarget || requestId, true);
                    }

                    // Prepare headers with authentication
                    const requestHeaders = {
                        ...this.authManager.getAuthHeaders(),
                        ...headers
                    };

                    // Prepare request options
                    const requestOptions = {
                        method,
                        headers: requestHeaders,
                        signal: AbortSignal.timeout(timeout)
                    };

                    // Add body for non-GET requests
                    if (body && method !== 'GET') {
                        if (body instanceof FormData) {
                            // Remove Content-Type for FormData (browser will set it with boundary)
                            delete requestOptions.headers['Content-Type'];
                            requestOptions.body = body;
                        } else if (typeof body === 'object') {
                            requestOptions.body = JSON.stringify(body);
                        } else {
                            requestOptions.body = body;
                        }
                    }

                    // Attempt request with retries
                    let lastError;
                    for (let attempt = 0; attempt <= retries; attempt++) {
                        try {
                            const response = await fetch(url, requestOptions);

                            if (response.ok) {
                                const contentType = response.headers.get('content-type');
                                let data;

                                if (contentType && contentType.includes('application/json')) {
                                    data = await response.json();
                                } else {
                                    data = await response.text();
                                }

                                return {
                                    success: true,
                                    data,
                                    status: response.status,
                                    headers: response.headers
                                };
                            } else {
                                // Handle HTTP errors
                                const errorData = await this.parseErrorResponse(response);
                                const error = new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
                                error.status = response.status;
                                error.data = errorData;

                                // Don't retry on authentication errors
                                if (response.status === 401 || response.status === 403) {
                                    this.handleAuthError();
                                    throw error;
                                }

                                // Don't retry on client errors (4xx)
                                if (response.status >= 400 && response.status < 500) {
                                    throw error;
                                }

                                lastError = error;
                            }
                        } catch (error) {
                            lastError = error;

                            // Don't retry on timeout or abort
                            if (error.name === 'TimeoutError' || error.name === 'AbortError') {
                                break;
                            }

                            // Don't retry on authentication errors
                            if (error.status === 401 || error.status === 403) {
                                break;
                            }
                        }

                        // Wait before retry (except on last attempt)
                        if (attempt < retries) {
                            await this.delay(this.retryDelay * (attempt + 1));
                        }
                    }

                    throw lastError;

                } catch (error) {
                    console.error(`API request failed: ${method} ${endpoint}`, error);

                    return {
                        success: false,
                        error: error.message || 'Request failed',
                        status: error.status || 0,
                        data: error.data || null
                    };
                } finally {
                    if (showLoading) {
                        this.setLoadingState(loadingTarget || requestId, false);
                    }
                }
            }

            async parseErrorResponse(response) {
                try {
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        return await response.json();
                    } else {
                        const text = await response.text();
                        return { message: text || response.statusText };
                    }
                } catch (error) {
                    return { message: response.statusText || 'Unknown error' };
                }
            }

            handleAuthError() {
                this.authManager.isAuthenticated = false;
                this.authManager.updateAuthStatus('unauthenticated');
                this.authManager.showMessage('认证失败，请重新设置token', 'error');
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            setLoadingState(target, isLoading) {
                this.loadingStates.set(target, isLoading);

                // Update button states
                if (typeof target === 'string' && target.endsWith('-btn')) {
                    const button = document.getElementById(target);
                    if (button) {
                        button.disabled = isLoading;

                        const originalText = button.dataset.originalText || button.textContent;
                        if (!button.dataset.originalText) {
                            button.dataset.originalText = originalText;
                        }

                        if (isLoading) {
                            button.innerHTML = `<span class="loading"></span> 处理中...`;
                        } else {
                            button.textContent = originalText;
                        }
                    }
                }

                // Update custom loading targets
                if (typeof target === 'string' && !target.endsWith('-btn')) {
                    const element = document.getElementById(target);
                    if (element) {
                        if (isLoading) {
                            element.classList.add('loading-state');
                        } else {
                            element.classList.remove('loading-state');
                        }
                    }
                }
            }

            isLoading(target) {
                return this.loadingStates.get(target) || false;
            }

            // Convenience methods for different HTTP methods
            async get(endpoint, options = {}) {
                return this.request(endpoint, { ...options, method: 'GET' });
            }

            async post(endpoint, body, options = {}) {
                return this.request(endpoint, { ...options, method: 'POST', body });
            }

            async put(endpoint, body, options = {}) {
                return this.request(endpoint, { ...options, method: 'PUT', body });
            }

            async delete(endpoint, options = {}) {
                return this.request(endpoint, { ...options, method: 'DELETE' });
            }

            async patch(endpoint, body, options = {}) {
                return this.request(endpoint, { ...options, method: 'PATCH', body });
            }

            // Specialized methods for available endpoints
            async processText(text, context = null) {
                // Use URL agent to process text content
                const body = { content: `${text}${context ? '\n\n上下文: ' + context : ''}` };

                return this.post('/api/v1/url-agent/extract-from-content', body, {
                    loadingTarget: 'process-text-btn'
                });
            }

            async sendChatMessage(message, conversationId = null) {
                // Add persona context to the message for the AI
                const enhancedMessage = `[人设：你是BountyGo的御姐型智能助手，成熟专业，略带傲娇，擅长推荐bounty任务和技术建议]

${message}`;

                const body = { message: enhancedMessage };

                return this.post('/api/v1/multi-agent/chat', body, {
                    loadingTarget: 'send-chat-btn'
                });
            }

            async analyzeImage(imageData, prompt = null, context = null) {
                // Use the real image analysis endpoint
                const body = {
                    image_base64: imageData,
                    additional_prompt: prompt,
                    context: context ? { context: context } : null
                };

                return this.post('/api/v1/url-agent/extract-from-image', body, {
                    loadingTarget: 'analyze-image-btn'
                });
            }

            async analyzeUrl(url, createTask = false) {
                const body = { url, auto_create: createTask };

                return this.post('/api/v1/url-agent/process', body, {
                    loadingTarget: 'analyze-url-btn'
                });
            }

            // File upload helper
            async uploadFile(file, endpoint, additionalData = {}) {
                const formData = new FormData();
                formData.append('file', file);

                // Add additional data to form
                Object.keys(additionalData).forEach(key => {
                    formData.append(key, additionalData[key]);
                });

                return this.post(endpoint, formData);
            }

            // Health check
            async healthCheck() {
                return this.get('/health', {
                    showLoading: false,
                    timeout: 5000,
                    retries: 1
                });
            }
        }

        // Text Processing Manager
        class TextProcessor {
            constructor(apiClient, authManager) {
                this.apiClient = apiClient;
                this.authManager = authManager;
                this.init();
            }

            init() {
                this.bindEvents();
            }

            bindEvents() {
                const processBtn = document.getElementById('process-text-btn');
                const textInput = document.getElementById('text-input');

                if (processBtn) {
                    processBtn.addEventListener('click', () => this.processText());
                }

                if (textInput) {
                    textInput.addEventListener('keydown', (e) => {
                        if (e.ctrlKey && e.key === 'Enter') {
                            this.processText();
                        }
                    });
                }
            }

            async processText() {
                const textInput = document.getElementById('text-input');
                const contextInput = document.getElementById('context-input');
                const resultsContainer = document.getElementById('text-results');
                const resultsContent = document.getElementById('text-results-content');

                if (!textInput || !resultsContainer || !resultsContent) {
                    console.error('Required elements not found');
                    return;
                }

                const text = textInput.value.trim();
                const context = contextInput ? contextInput.value.trim() : null;

                // Validation
                if (!text) {
                    this.authManager.showMessage('请输入要处理的文本内容', 'warning');
                    textInput.focus();
                    return;
                }

                if (!this.authManager.isTokenValid()) {
                    this.authManager.showMessage('请先设置有效的API Token', 'warning');
                    return;
                }

                try {
                    // Clear previous results
                    resultsContainer.classList.add('hidden');
                    resultsContent.textContent = '';

                    // Show processing message
                    this.authManager.showMessage('正在处理文本...', 'info');

                    // Call API
                    const response = await this.apiClient.processText(text, context);

                    if (response.success) {
                        this.displayResults(response.data, resultsContainer, resultsContent);
                        this.authManager.showMessage('文本处理完成', 'success');
                    } else {
                        this.handleError(response.error, response.status);
                    }

                } catch (error) {
                    console.error('Text processing error:', error);
                    this.handleError(error.message || '处理文本时发生未知错误');
                }
            }

            displayResults(data, container, content) {
                try {
                    // Format the response data
                    let formattedResult;

                    if (typeof data === 'object') {
                        // If response has specific structure, format accordingly
                        if (data.result) {
                            formattedResult = data.result;
                        } else if (data.response) {
                            formattedResult = data.response;
                        } else if (data.content) {
                            formattedResult = data.content;
                        } else {
                            // Pretty print JSON
                            formattedResult = JSON.stringify(data, null, 2);
                        }
                    } else {
                        formattedResult = String(data);
                    }

                    content.textContent = formattedResult;
                    container.classList.remove('hidden');

                    // Scroll to results
                    container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                } catch (error) {
                    console.error('Error displaying results:', error);
                    content.textContent = '结果显示出错: ' + error.message;
                    container.classList.remove('hidden');
                }
            }

            handleError(errorMessage, status = null) {
                const resultsContainer = document.getElementById('text-results');
                const resultsContent = document.getElementById('text-results-content');

                let userMessage = '文本处理失败';
                let detailedError = errorMessage;

                // Provide user-friendly error messages based on status
                if (status === 400) {
                    userMessage = '请求参数错误，请检查输入内容';
                } else if (status === 401) {
                    userMessage = 'Token无效，请重新设置';
                } else if (status === 403) {
                    userMessage = '没有权限访问此功能';
                } else if (status === 429) {
                    userMessage = '请求过于频繁，请稍后再试';
                } else if (status === 500) {
                    userMessage = '服务器内部错误，请稍后再试';
                } else if (status === 503) {
                    userMessage = '服务暂时不可用，请稍后再试';
                } else if (errorMessage.includes('fetch')) {
                    userMessage = '网络连接错误，请检查网络连接';
                } else if (errorMessage.includes('timeout')) {
                    userMessage = '请求超时，请稍后再试';
                }

                this.authManager.showMessage(userMessage, 'error');

                // Show detailed error in results area
                if (resultsContainer && resultsContent) {
                    resultsContent.textContent = `错误: ${detailedError}`;
                    resultsContainer.classList.remove('hidden');
                }
            }

            clearResults() {
                const resultsContainer = document.getElementById('text-results');
                const resultsContent = document.getElementById('text-results-content');

                if (resultsContainer && resultsContent) {
                    resultsContent.textContent = '';
                    resultsContainer.classList.add('hidden');
                }
            }

            // Utility method to get current input values
            getCurrentInput() {
                const textInput = document.getElementById('text-input');
                const contextInput = document.getElementById('context-input');

                return {
                    text: textInput ? textInput.value.trim() : '',
                    context: contextInput ? contextInput.value.trim() : null
                };
            }

            // Method to set input values (useful for testing or pre-filling)
            setInput(text, context = null) {
                const textInput = document.getElementById('text-input');
                const contextInput = document.getElementById('context-input');

                if (textInput) {
                    textInput.value = text;
                }

                if (contextInput && context) {
                    contextInput.value = context;
                }
            }
        }

        // Chat Manager
        class ChatManager {
            constructor(apiClient, authManager) {
                this.apiClient = apiClient;
                this.authManager = authManager;
                this.conversationId = null;
                this.chatHistory = [];
                this.suggestions = [
                    "解释这段代码的功能",
                    "帮我优化这个算法",
                    "这个错误如何解决？",
                    "推荐最佳实践",
                    "代码审查建议"
                ];
                this.init();
            }

            init() {
                this.bindEvents();
                this.loadChatHistory();
                this.displaySuggestions();
            }

            bindEvents() {
                const sendBtn = document.getElementById('send-chat-btn');
                const chatInput = document.getElementById('chat-input');
                const clearBtn = document.getElementById('clear-chat-btn');

                if (sendBtn) {
                    sendBtn.addEventListener('click', () => this.sendMessage());
                }

                if (chatInput) {
                    chatInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });

                    chatInput.addEventListener('input', () => {
                        this.adjustInputHeight();
                    });
                }

                if (clearBtn) {
                    clearBtn.addEventListener('click', () => this.clearChat());
                }
            }

            async sendMessage() {
                const chatInput = document.getElementById('chat-input');
                const message = chatInput.value.trim();

                if (!message) {
                    this.authManager.showMessage('请输入消息内容', 'warning');
                    chatInput.focus();
                    return;
                }

                if (!this.authManager.isTokenValid()) {
                    this.authManager.showMessage('请先设置有效的API Token', 'warning');
                    return;
                }

                try {
                    // Add user message to chat
                    this.addMessage(message, 'user');
                    chatInput.value = '';
                    this.adjustInputHeight();

                    // Show typing indicator
                    const typingId = this.showTypingIndicator();

                    // Call API
                    console.log('Sending chat message:', message);
                    const response = await this.apiClient.sendChatMessage(message, this.conversationId);
                    console.log('Chat response:', response);

                    // Remove typing indicator
                    this.removeTypingIndicator(typingId);

                    if (response.success) {
                        const data = response.data;

                        // Extract the assistant's message from the multi-agent response
                        let assistantMessage = data.message || '我收到了你的消息，但暂时无法给出回复。';

                        // Add task info if available (for bounty recommendations)
                        if (data.task_info) {
                            const taskInfo = data.task_info;
                            if (taskInfo.title) {
                                assistantMessage += `\n\n🎯 **推荐任务**: ${taskInfo.title}`;
                            }
                            if (taskInfo.description) {
                                assistantMessage += `\n📝 **任务描述**: ${taskInfo.description}`;
                            }
                            if (taskInfo.reward && taskInfo.reward_currency) {
                                assistantMessage += `\n💰 **奖励**: ${taskInfo.reward} ${taskInfo.reward_currency}`;
                            }
                            if (taskInfo.tags && taskInfo.tags.length > 0) {
                                assistantMessage += `\n🏷️ **技术标签**: ${taskInfo.tags.join(', ')}`;
                            }
                        }

                        this.addMessage(assistantMessage, 'assistant');

                        // Update suggestions if provided
                        if (data.suggestions && data.suggestions.length > 0) {
                            this.updateSuggestions(data.suggestions);
                        } else {
                            // Default suggestions for bounty platform
                            const defaultSuggestions = [
                                '推荐适合我的bounty',
                                '最新的高薪任务',
                                '前端开发任务',
                                '区块链项目',
                                '我的技能匹配度'
                            ];
                            this.updateSuggestions(defaultSuggestions);
                        }

                        this.saveChatHistory();

                    } else {
                        this.handleError(response.error, response.status);
                    }

                } catch (error) {
                    console.error('Chat error:', error);
                    // Remove typing indicator on error
                    this.removeTypingIndicator(typingId);
                    this.handleError(error.message || '发送消息时发生未知错误');
                }
            }

            addMessage(content, type) {
                const messagesContainer = document.getElementById('chat-messages');
                if (!messagesContainer) return;

                // Remove welcome message if it exists
                const welcomeMsg = messagesContainer.querySelector('.text-center');
                if (welcomeMsg) {
                    welcomeMsg.remove();
                }

                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${type}`;
                messageDiv.textContent = content;

                messagesContainer.appendChild(messageDiv);

                // Add to history
                this.chatHistory.push({ content, type, timestamp: Date.now() });

                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            showTypingIndicator() {
                const messagesContainer = document.getElementById('chat-messages');
                if (!messagesContainer) return null;

                const typingDiv = document.createElement('div');
                const typingId = 'typing-' + Date.now();
                typingDiv.id = typingId;
                typingDiv.className = 'chat-message assistant';
                typingDiv.innerHTML = '<span class="loading"></span> 正在思考...';

                messagesContainer.appendChild(typingDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                return typingId;
            }

            removeTypingIndicator(typingId) {
                if (typingId) {
                    const typingDiv = document.getElementById(typingId);
                    if (typingDiv) {
                        typingDiv.remove();
                    }
                }
            }

            clearChat() {
                const messagesContainer = document.getElementById('chat-messages');
                if (!messagesContainer) return;

                messagesContainer.innerHTML = '<div class="text-center text-muted">开始对话...</div>';

                this.chatHistory = [];
                this.conversationId = null;
                this.saveChatHistory();
                this.displaySuggestions();

                this.authManager.showMessage('对话已清除', 'info');
            }

            displaySuggestions() {
                const suggestionsContainer = document.getElementById('chat-suggestions');
                if (!suggestionsContainer) return;

                suggestionsContainer.innerHTML = '';

                this.suggestions.forEach(suggestion => {
                    const suggestionBtn = document.createElement('button');
                    suggestionBtn.className = 'suggestion-btn';
                    suggestionBtn.textContent = suggestion;
                    suggestionBtn.addEventListener('click', () => {
                        this.fillSuggestion(suggestion);
                    });

                    suggestionsContainer.appendChild(suggestionBtn);
                });
            }

            updateSuggestions(newSuggestions) {
                this.suggestions = [...newSuggestions];
                this.displaySuggestions();
            }

            fillSuggestion(suggestion) {
                const chatInput = document.getElementById('chat-input');
                if (chatInput) {
                    chatInput.value = suggestion;
                    chatInput.focus();
                    this.adjustInputHeight();
                }
            }

            adjustInputHeight() {
                const chatInput = document.getElementById('chat-input');
                if (!chatInput) return;

                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
            }

            handleError(errorMessage, status = null) {
                let userMessage = '发送消息失败';

                // Provide user-friendly error messages based on status
                if (status === 400) {
                    userMessage = '消息格式错误，请重新输入';
                } else if (status === 401) {
                    userMessage = 'Token无效，请重新设置';
                } else if (status === 403) {
                    userMessage = '没有权限使用聊天功能';
                } else if (status === 429) {
                    userMessage = '消息发送过于频繁，请稍后再试';
                } else if (status === 500) {
                    userMessage = '服务器内部错误，请稍后再试';
                } else if (status === 503) {
                    userMessage = '聊天服务暂时不可用，请稍后再试';
                } else if (errorMessage.includes('fetch')) {
                    userMessage = '网络连接错误，请检查网络连接';
                } else if (errorMessage.includes('timeout')) {
                    userMessage = '请求超时，请稍后再试';
                }

                this.authManager.showMessage(userMessage, 'error');

                // Add error message to chat
                this.addMessage(`错误: ${userMessage}`, 'assistant');
            }

            saveChatHistory() {
                try {
                    const historyData = {
                        history: this.chatHistory,
                        conversationId: this.conversationId,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('bountygo_chat_history', JSON.stringify(historyData));
                } catch (error) {
                    console.error('Error saving chat history:', error);
                }
            }

            loadChatHistory() {
                try {
                    const historyData = localStorage.getItem('bountygo_chat_history');
                    if (historyData) {
                        const parsed = JSON.parse(historyData);

                        // Only load recent history (within 24 hours)
                        const dayAgo = Date.now() - (24 * 60 * 60 * 1000);
                        if (parsed.timestamp > dayAgo) {
                            this.chatHistory = parsed.history || [];
                            this.conversationId = parsed.conversationId;

                            // Restore chat messages
                            if (this.chatHistory.length > 0) {
                                const messagesContainer = document.getElementById('chat-messages');
                                if (messagesContainer) {
                                    messagesContainer.innerHTML = '';

                                    this.chatHistory.forEach(msg => {
                                        const messageDiv = document.createElement('div');
                                        messageDiv.className = `chat-message ${msg.type}`;
                                        messageDiv.textContent = msg.content;
                                        messagesContainer.appendChild(messageDiv);
                                    });

                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error loading chat history:', error);
                }
            }

            // Utility methods
            getCurrentConversationId() {
                return this.conversationId;
            }

            getChatHistory() {
                return [...this.chatHistory];
            }

            // Method to programmatically send a message (useful for testing)
            async sendProgrammaticMessage(message) {
                const chatInput = document.getElementById('chat-input');
                if (chatInput) {
                    chatInput.value = message;
                    await this.sendMessage();
                }
            }
        }

        // Image Processing Manager
        class ImageProcessor {
            constructor(apiClient, authManager) {
                this.apiClient = apiClient;
                this.authManager = authManager;
                this.currentFile = null;
                this.maxFileSize = 10 * 1024 * 1024; // 10MB
                this.allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
                this.init();
            }

            init() {
                this.bindEvents();
            }

            bindEvents() {
                const fileInput = document.getElementById('image-input');
                const uploadArea = document.getElementById('image-upload');
                const analyzeBtn = document.getElementById('analyze-image-btn');

                if (fileInput) {
                    fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                }

                if (uploadArea) {
                    // Drag and drop events
                    uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                    uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                    uploadArea.addEventListener('drop', (e) => this.handleDrop(e));
                    uploadArea.addEventListener('click', () => fileInput?.click());
                }

                if (analyzeBtn) {
                    analyzeBtn.addEventListener('click', () => this.analyzeImage());
                }
            }

            handleFileSelect(event) {
                const file = event.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }

            handleDragOver(event) {
                event.preventDefault();
                event.stopPropagation();
                const uploadArea = document.getElementById('image-upload');
                if (uploadArea) {
                    uploadArea.classList.add('dragover');
                }
            }

            handleDragLeave(event) {
                event.preventDefault();
                event.stopPropagation();
                const uploadArea = document.getElementById('image-upload');
                if (uploadArea) {
                    uploadArea.classList.remove('dragover');
                }
            }

            handleDrop(event) {
                event.preventDefault();
                event.stopPropagation();

                const uploadArea = document.getElementById('image-upload');
                if (uploadArea) {
                    uploadArea.classList.remove('dragover');
                }

                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    this.processFile(files[0]);
                }
            }

            processFile(file) {
                // Validate file type
                if (!this.allowedTypes.includes(file.type)) {
                    this.authManager.showMessage('不支持的文件类型。请选择 JPEG, PNG, GIF 或 WebP 格式的图片', 'error');
                    return;
                }

                // Validate file size
                if (file.size > this.maxFileSize) {
                    this.authManager.showMessage('文件大小超过限制（最大 10MB）', 'error');
                    return;
                }

                this.currentFile = file;
                this.displayPreview(file);
                this.enableAnalyzeButton();

                this.authManager.showMessage(`图片已选择: ${file.name} (${this.formatFileSize(file.size)})`, 'success');
            }

            displayPreview(file) {
                const previewContainer = document.getElementById('image-preview');
                if (!previewContainer) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    previewContainer.innerHTML = `
                        <img src="${e.target.result}" alt="预览图片">
                        <p class="text-small text-muted mt-2">${file.name} - ${this.formatFileSize(file.size)}</p>
                    `;
                    previewContainer.classList.remove('hidden');
                };
                reader.readAsDataURL(file);
            }

            enableAnalyzeButton() {
                const analyzeBtn = document.getElementById('analyze-image-btn');
                if (analyzeBtn) {
                    analyzeBtn.disabled = false;
                }
            }

            disableAnalyzeButton() {
                const analyzeBtn = document.getElementById('analyze-image-btn');
                if (analyzeBtn) {
                    analyzeBtn.disabled = true;
                }
            }

            async analyzeImage() {
                if (!this.currentFile) {
                    this.authManager.showMessage('请先选择图片文件', 'warning');
                    return;
                }

                if (!this.authManager.isTokenValid()) {
                    this.authManager.showMessage('请先设置有效的API Token', 'warning');
                    return;
                }

                const promptInput = document.getElementById('image-prompt');
                const contextInput = document.getElementById('image-context');
                const resultsContainer = document.getElementById('image-results');
                const resultsContent = document.getElementById('image-results-content');

                const prompt = promptInput ? promptInput.value.trim() : null;
                const context = contextInput ? contextInput.value.trim() : null;

                try {
                    // Clear previous results
                    if (resultsContainer && resultsContent) {
                        resultsContainer.classList.add('hidden');
                        resultsContent.textContent = '';
                    }

                    // Show processing message
                    this.authManager.showMessage('正在分析图片...', 'info');

                    // Convert file to base64
                    const base64Data = await this.fileToBase64(this.currentFile);

                    // Call API
                    const response = await this.apiClient.analyzeImage(base64Data, prompt, context);

                    if (response.success) {
                        this.displayResults(response.data, resultsContainer, resultsContent);
                        this.authManager.showMessage('图片分析完成', 'success');
                    } else {
                        this.handleError(response.error, response.status);
                    }

                } catch (error) {
                    console.error('Image analysis error:', error);
                    this.handleError(error.message || '分析图片时发生未知错误');
                }
            }

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        // Remove data URL prefix to get pure base64
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            displayResults(data, container, content) {
                try {
                    let formattedResult;

                    if (typeof data === 'object') {
                        // If response has specific structure, format accordingly
                        if (data.analysis) {
                            formattedResult = data.analysis;
                        } else if (data.result) {
                            formattedResult = data.result;
                        } else if (data.description) {
                            formattedResult = data.description;
                        } else if (data.content) {
                            formattedResult = data.content;
                        } else {
                            // Pretty print JSON
                            formattedResult = JSON.stringify(data, null, 2);
                        }
                    } else {
                        formattedResult = String(data);
                    }

                    content.textContent = formattedResult;
                    container.classList.remove('hidden');

                    // Scroll to results
                    container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                } catch (error) {
                    console.error('Error displaying results:', error);
                    content.textContent = '结果显示出错: ' + error.message;
                    container.classList.remove('hidden');
                }
            }

            handleError(errorMessage, status = null) {
                let userMessage = '图片分析失败';
                let detailedError = errorMessage;

                // Provide user-friendly error messages based on status
                if (status === 400) {
                    userMessage = '请求参数错误，请检查图片格式和大小';
                } else if (status === 401) {
                    userMessage = 'Token无效，请重新设置';
                } else if (status === 403) {
                    userMessage = '没有权限使用图片分析功能';
                } else if (status === 413) {
                    userMessage = '图片文件过大，请选择较小的图片';
                } else if (status === 415) {
                    userMessage = '不支持的图片格式';
                } else if (status === 429) {
                    userMessage = '请求过于频繁，请稍后再试';
                } else if (status === 500) {
                    userMessage = '服务器内部错误，请稍后再试';
                } else if (status === 503) {
                    userMessage = '图片分析服务暂时不可用，请稍后再试';
                } else if (errorMessage.includes('fetch')) {
                    userMessage = '网络连接错误，请检查网络连接';
                } else if (errorMessage.includes('timeout')) {
                    userMessage = '请求超时，请稍后再试';
                }

                this.authManager.showMessage(userMessage, 'error');

                // Show detailed error in results area
                const resultsContainer = document.getElementById('image-results');
                const resultsContent = document.getElementById('image-results-content');

                if (resultsContainer && resultsContent) {
                    resultsContent.textContent = `错误: ${detailedError}`;
                    resultsContainer.classList.remove('hidden');
                }
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';

                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));

                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            clearImage() {
                this.currentFile = null;

                // Clear file input
                const fileInput = document.getElementById('image-input');
                if (fileInput) {
                    fileInput.value = '';
                }

                // Clear preview
                const previewContainer = document.getElementById('image-preview');
                if (previewContainer) {
                    previewContainer.innerHTML = '';
                    previewContainer.classList.add('hidden');
                }

                // Clear inputs
                const promptInput = document.getElementById('image-prompt');
                const contextInput = document.getElementById('image-context');
                if (promptInput) promptInput.value = '';
                if (contextInput) contextInput.value = '';

                // Clear results
                const resultsContainer = document.getElementById('image-results');
                const resultsContent = document.getElementById('image-results-content');
                if (resultsContainer && resultsContent) {
                    resultsContent.textContent = '';
                    resultsContainer.classList.add('hidden');
                }

                this.disableAnalyzeButton();

                this.authManager.showMessage('图片已清除', 'info');
            }

            // Utility methods
            getCurrentFile() {
                return this.currentFile;
            }

            isFileSelected() {
                return this.currentFile !== null;
            }

            getSupportedTypes() {
                return [...this.allowedTypes];
            }

            getMaxFileSize() {
                return this.maxFileSize;
            }
        }

        // URL Analysis Manager
        class URLAnalyzer {
            constructor(apiClient, authManager) {
                this.apiClient = apiClient;
                this.authManager = authManager;
                this.init();
            }

            init() {
                this.bindEvents();
            }

            bindEvents() {
                const analyzeBtn = document.getElementById('analyze-url-btn');
                const urlInput = document.getElementById('url-input');

                if (analyzeBtn) {
                    analyzeBtn.addEventListener('click', () => this.analyzeURL());
                }

                if (urlInput) {
                    urlInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.analyzeURL();
                        }
                    });

                    urlInput.addEventListener('input', () => {
                        this.validateURLInput();
                    });
                }
            }

            validateURLInput() {
                const urlInput = document.getElementById('url-input');
                if (!urlInput) return;

                const url = urlInput.value.trim();

                if (url && !this.isValidURL(url)) {
                    urlInput.classList.add('error');
                } else {
                    urlInput.classList.remove('error');
                }
            }

            isValidURL(string) {
                try {
                    const url = new URL(string);
                    return url.protocol === 'http:' || url.protocol === 'https:';
                } catch (_) {
                    return false;
                }
            }

            async analyzeURL() {
                const urlInput = document.getElementById('url-input');
                const createTaskCheckbox = document.getElementById('create-task-checkbox');
                const resultsContainer = document.getElementById('url-results');
                const resultsContent = document.getElementById('url-results-content');

                if (!urlInput || !resultsContainer || !resultsContent) {
                    console.error('Required elements not found');
                    return;
                }

                const url = urlInput.value.trim();
                const createTask = createTaskCheckbox ? createTaskCheckbox.checked : false;

                // Validation
                if (!url) {
                    this.authManager.showMessage('请输入URL链接', 'warning');
                    urlInput.focus();
                    return;
                }

                if (!this.isValidURL(url)) {
                    this.authManager.showMessage('请输入有效的URL链接（必须以http://或https://开头）', 'error');
                    urlInput.focus();
                    urlInput.classList.add('error');
                    return;
                }

                if (!this.authManager.isTokenValid()) {
                    this.authManager.showMessage('请先设置有效的API Token', 'warning');
                    return;
                }

                try {
                    // Clear previous results
                    resultsContainer.classList.add('hidden');
                    resultsContent.textContent = '';

                    // Remove error styling
                    urlInput.classList.remove('error');

                    // Show processing message
                    this.authManager.showMessage('正在分析URL...', 'info');

                    // Call API
                    const response = await this.apiClient.analyzeUrl(url, createTask);

                    if (response.success) {
                        this.displayResults(response.data, resultsContainer, resultsContent, createTask);

                        if (createTask) {
                            this.authManager.showMessage('URL分析完成，任务已创建', 'success');
                        } else {
                            this.authManager.showMessage('URL分析完成', 'success');
                        }
                    } else {
                        this.handleError(response.error, response.status, url);
                    }

                } catch (error) {
                    console.error('URL analysis error:', error);
                    this.handleError(error.message || '分析URL时发生未知错误', null, url);
                }
            }

            displayResults(data, container, content, createTask) {
                try {
                    let formattedResult = '';

                    if (typeof data === 'object') {
                        // Format different types of responses
                        if (data.analysis) {
                            formattedResult = data.analysis;
                        } else if (data.summary) {
                            formattedResult = data.summary;
                        } else if (data.content) {
                            formattedResult = data.content;
                        } else if (data.result) {
                            formattedResult = data.result;
                        } else {
                            // Handle structured response
                            if (data.title) {
                                formattedResult += `标题: ${data.title}\n\n`;
                            }

                            if (data.description) {
                                formattedResult += `描述: ${data.description}\n\n`;
                            }

                            if (data.keywords && Array.isArray(data.keywords)) {
                                formattedResult += `关键词: ${data.keywords.join(', ')}\n\n`;
                            }

                            if (data.main_content) {
                                formattedResult += `主要内容:\n${data.main_content}\n\n`;
                            }

                            if (createTask && data.task_id) {
                                formattedResult += `任务ID: ${data.task_id}\n\n`;
                            }

                            // If no specific fields, show JSON
                            if (!formattedResult) {
                                formattedResult = JSON.stringify(data, null, 2);
                            }
                        }
                    } else {
                        formattedResult = String(data);
                    }

                    content.textContent = formattedResult;
                    container.classList.remove('hidden');

                    // Scroll to results
                    container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                } catch (error) {
                    console.error('Error displaying results:', error);
                    content.textContent = '结果显示出错: ' + error.message;
                    container.classList.remove('hidden');
                }
            }

            handleError(errorMessage, status = null, url = null) {
                const resultsContainer = document.getElementById('url-results');
                const resultsContent = document.getElementById('url-results-content');
                const urlInput = document.getElementById('url-input');

                let userMessage = 'URL分析失败';
                let detailedError = errorMessage;

                // Provide user-friendly error messages based on status and error content
                if (status === 400) {
                    if (errorMessage.includes('URL解析Agent未配置') || errorMessage.includes('ProcessingError')) {
                        userMessage = 'URL解析服务未正确配置，请联系管理员';
                        detailedError = '后端URL Agent服务状态异常，可能是Playwright未正确安装或配置';
                    } else {
                        userMessage = 'URL格式错误或无法访问';
                        if (urlInput) urlInput.classList.add('error');
                    }
                } else if (status === 401) {
                    userMessage = 'Token无效，请重新设置';
                } else if (status === 403) {
                    userMessage = '没有权限访问此URL或功能';
                } else if (status === 404) {
                    userMessage = 'URL不存在或无法访问';
                    if (urlInput) urlInput.classList.add('error');
                } else if (status === 408) {
                    userMessage = '访问URL超时，请检查网络或稍后再试';
                } else if (status === 429) {
                    userMessage = '请求过于频繁，请稍后再试';
                } else if (status === 500) {
                    if (errorMessage.includes('URL处理失败') || errorMessage.includes('ProcessingError')) {
                        userMessage = 'URL解析服务异常，可能是动态内容网站需要特殊处理';
                        detailedError = '对于Twitter/X等动态网站，需要Playwright正确配置才能解析内容';
                    } else {
                        userMessage = '服务器内部错误，请稍后再试';
                    }
                } else if (status === 502) {
                    userMessage = '无法访问目标URL，可能是网络问题';
                } else if (status === 503) {
                    userMessage = 'URL分析服务暂时不可用，请稍后再试';
                } else if (errorMessage.includes('fetch')) {
                    userMessage = '网络连接错误，请检查网络连接';
                } else if (errorMessage.includes('timeout')) {
                    userMessage = '请求超时，请稍后再试';
                } else if (errorMessage.includes('CORS')) {
                    userMessage = '跨域访问被阻止，无法分析此URL';
                }

                this.authManager.showMessage(userMessage, 'error');

                // Show detailed error in results area with troubleshooting tips
                if (resultsContainer && resultsContent) {
                    let errorDisplay = `❌ 错误: ${userMessage}\n\n`;
                    
                    if (url) {
                        errorDisplay += `🔗 分析的URL: ${url}\n\n`;
                        
                        // Add specific tips for different URL types
                        if (url.includes('x.com') || url.includes('twitter.com')) {
                            errorDisplay += `💡 提示: Twitter/X 链接需要特殊处理\n`;
                            errorDisplay += `- 这类动态网站需要 Playwright 渲染页面内容\n`;
                            errorDisplay += `- 请确保后端 URL Agent 服务正常运行\n`;
                            errorDisplay += `- 可以尝试使用文本分析功能代替\n\n`;
                        } else if (url.includes('github.com')) {
                            errorDisplay += `💡 提示: GitHub 链接通常可以正常解析\n`;
                            errorDisplay += `- 请检查链接是否可以公开访问\n`;
                            errorDisplay += `- 确保不是私有仓库\n\n`;
                        }
                    }
                    
                    errorDisplay += `🔧 技术详情: ${detailedError}`;
                    
                    resultsContent.textContent = errorDisplay;
                    resultsContainer.classList.remove('hidden');
                }
            }

            clearResults() {
                const resultsContainer = document.getElementById('url-results');
                const resultsContent = document.getElementById('url-results-content');

                if (resultsContainer && resultsContent) {
                    resultsContent.textContent = '';
                    resultsContainer.classList.add('hidden');
                }
            }

            clearInput() {
                const urlInput = document.getElementById('url-input');
                const createTaskCheckbox = document.getElementById('create-task-checkbox');

                if (urlInput) {
                    urlInput.value = '';
                    urlInput.classList.remove('error');
                }

                if (createTaskCheckbox) {
                    createTaskCheckbox.checked = false;
                }

                this.clearResults();
            }

            // Utility methods
            getCurrentURL() {
                const urlInput = document.getElementById('url-input');
                return urlInput ? urlInput.value.trim() : '';
            }

            setURL(url) {
                const urlInput = document.getElementById('url-input');
                if (urlInput) {
                    urlInput.value = url;
                    this.validateURLInput();
                }
            }

            isCreateTaskEnabled() {
                const createTaskCheckbox = document.getElementById('create-task-checkbox');
                return createTaskCheckbox ? createTaskCheckbox.checked : false;
            }

            setCreateTask(enabled) {
                const createTaskCheckbox = document.getElementById('create-task-checkbox');
                if (createTaskCheckbox) {
                    createTaskCheckbox.checked = enabled;
                }
            }

            // Method to analyze URL programmatically (useful for testing)
            async analyzeURLProgrammatically(url, createTask = false) {
                this.setURL(url);
                this.setCreateTask(createTask);
                await this.analyzeURL();
            }

            // URL validation helper
            getDomainFromURL(url) {
                try {
                    const urlObj = new URL(url);
                    return urlObj.hostname;
                } catch (_) {
                    return null;
                }
            }

            // Check if URL is accessible (basic check)
            async checkURLAccessibility(url) {
                try {
                    const response = await fetch(url, {
                        method: 'HEAD',
                        mode: 'no-cors',
                        timeout: 5000
                    });
                    return true;
                } catch (error) {
                    return false;
                }
            }
        }

        // Global Error Handler Class
        class GlobalErrorHandler {
            constructor() {
                this.errorLog = [];
                this.maxLogSize = 100;
                this.retryAttempts = new Map();
                this.maxRetryAttempts = 3;
                this.init();
            }

            init() {
                this.setupGlobalErrorHandling();
                this.setupNetworkErrorHandling();
                this.setupValidationRules();
            }

            setupGlobalErrorHandling() {
                // Catch unhandled JavaScript errors
                window.addEventListener('error', (event) => {
                    this.logError({
                        type: 'javascript',
                        message: event.message,
                        filename: event.filename,
                        lineno: event.lineno,
                        colno: event.colno,
                        stack: event.error?.stack,
                        timestamp: Date.now()
                    });

                    this.showUserFriendlyError('页面发生了一个错误，请刷新页面重试');
                });

                // Catch unhandled promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    this.logError({
                        type: 'promise',
                        message: event.reason?.message || 'Promise rejection',
                        stack: event.reason?.stack,
                        timestamp: Date.now()
                    });

                    this.showUserFriendlyError('操作失败，请重试');
                    event.preventDefault(); // Prevent console error
                });
            }

            setupNetworkErrorHandling() {
                // Monitor fetch requests for network issues
                const originalFetch = window.fetch;
                window.fetch = async (...args) => {
                    try {
                        const response = await originalFetch(...args);

                        // Reset retry count on successful request
                        if (response.ok) {
                            this.retryAttempts.delete(args[0]);
                        }

                        return response;
                    } catch (error) {
                        this.handleNetworkError(error, args[0]);
                        throw error;
                    }
                };
            }

            setupValidationRules() {
                this.validationRules = {
                    required: (value) => value && value.trim().length > 0,
                    url: (value) => {
                        try {
                            const url = new URL(value);
                            return url.protocol === 'http:' || url.protocol === 'https:';
                        } catch {
                            return false;
                        }
                    },
                    email: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value),
                    minLength: (value, min) => value && value.length >= min,
                    maxLength: (value, max) => value && value.length <= max,
                    fileSize: (file, maxSize) => file && file.size <= maxSize,
                    fileType: (file, allowedTypes) => file && allowedTypes.includes(file.type)
                };
            }

            logError(errorInfo) {
                this.errorLog.push(errorInfo);

                // Keep log size manageable
                if (this.errorLog.length > this.maxLogSize) {
                    this.errorLog.shift();
                }

                // Log to console in development
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    console.error('Error logged:', errorInfo);
                }
            }

            handleNetworkError(error, url) {
                const urlString = typeof url === 'string' ? url : url.toString();

                this.logError({
                    type: 'network',
                    message: error.message,
                    url: urlString,
                    timestamp: Date.now()
                });

                // Determine error type and show appropriate message
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    this.showUserFriendlyError('网络连接失败，请检查网络连接');
                } else if (error.name === 'AbortError') {
                    this.showUserFriendlyError('请求被取消');
                } else if (error.name === 'TimeoutError') {
                    this.showUserFriendlyError('请求超时，请稍后重试');
                } else {
                    this.showUserFriendlyError('网络请求失败，请重试');
                }
            }

            handleAPIError(error, status, endpoint) {
                const errorInfo = {
                    type: 'api',
                    message: error,
                    status: status,
                    endpoint: endpoint,
                    timestamp: Date.now()
                };

                this.logError(errorInfo);

                let userMessage = this.getAPIErrorMessage(status, error);
                let errorType = this.getErrorType(status);

                this.showUserFriendlyError(userMessage, errorType);

                return { userMessage, errorType };
            }

            getAPIErrorMessage(status, originalError) {
                const errorMessages = {
                    400: '请求参数错误，请检查输入内容',
                    401: 'Token无效或已过期，请重新设置',
                    403: '没有权限访问此功能',
                    404: '请求的资源不存在',
                    408: '请求超时，请稍后重试',
                    413: '上传的文件过大',
                    415: '不支持的文件格式',
                    422: '输入数据格式错误',
                    429: '请求过于频繁，请稍后再试',
                    500: '服务器内部错误，请稍后重试',
                    502: '服务器网关错误',
                    503: '服务暂时不可用，请稍后重试',
                    504: '服务器响应超时'
                };

                return errorMessages[status] || `请求失败 (${status}): ${originalError}`;
            }

            getErrorType(status) {
                if (status >= 400 && status < 500) {
                    return status === 401 || status === 403 ? 'warning' : 'error';
                } else if (status >= 500) {
                    return 'error';
                } else {
                    return 'warning';
                }
            }

            validateInput(value, rules, fieldName = '输入') {
                const errors = [];

                for (const rule of rules) {
                    if (typeof rule === 'string') {
                        // Simple rule name
                        if (!this.validationRules[rule](value)) {
                            errors.push(this.getValidationMessage(rule, fieldName));
                        }
                    } else if (typeof rule === 'object') {
                        // Rule with parameters
                        const { type, param, message } = rule;
                        if (!this.validationRules[type](value, param)) {
                            errors.push(message || this.getValidationMessage(type, fieldName, param));
                        }
                    }
                }

                return errors;
            }

            getValidationMessage(rule, fieldName, param) {
                const messages = {
                    required: `${fieldName}不能为空`,
                    url: `${fieldName}必须是有效的URL地址`,
                    email: `${fieldName}必须是有效的邮箱地址`,
                    minLength: `${fieldName}长度不能少于${param}个字符`,
                    maxLength: `${fieldName}长度不能超过${param}个字符`,
                    fileSize: `文件大小不能超过${this.formatFileSize(param)}`,
                    fileType: `不支持的文件类型`
                };

                return messages[rule] || `${fieldName}格式错误`;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            showUserFriendlyError(message, type = 'error') {
                // Use existing message system if available
                if (window.authManager && window.authManager.showMessage) {
                    window.authManager.showMessage(message, type);
                } else {
                    // Fallback to console and alert
                    console.error(message);
                    if (type === 'error') {
                        alert(message);
                    }
                }
            }

            showValidationErrors(errors, targetElement = null) {
                if (errors.length === 0) return;

                const errorMessage = errors.join('; ');
                this.showUserFriendlyError(errorMessage, 'warning');

                // Highlight the target element if provided
                if (targetElement) {
                    targetElement.classList.add('error');
                    targetElement.focus();

                    // Remove error styling after user starts typing
                    const removeError = () => {
                        targetElement.classList.remove('error');
                        targetElement.removeEventListener('input', removeError);
                    };
                    targetElement.addEventListener('input', removeError);
                }
            }

            // Retry mechanism for failed operations
            async retryOperation(operation, maxRetries = this.maxRetryAttempts) {
                let lastError;

                for (let attempt = 0; attempt <= maxRetries; attempt++) {
                    try {
                        const result = await operation();
                        return result;
                    } catch (error) {
                        lastError = error;

                        // Don't retry on client errors (4xx)
                        if (error.status >= 400 && error.status < 500) {
                            break;
                        }

                        // Wait before retry (exponential backoff)
                        if (attempt < maxRetries) {
                            await this.delay(Math.pow(2, attempt) * 1000);
                        }
                    }
                }

                throw lastError;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // Get error statistics for debugging
            getErrorStats() {
                const stats = {
                    total: this.errorLog.length,
                    byType: {},
                    recent: this.errorLog.slice(-10)
                };

                this.errorLog.forEach(error => {
                    stats.byType[error.type] = (stats.byType[error.type] || 0) + 1;
                });

                return stats;
            }

            // Clear error log
            clearErrorLog() {
                this.errorLog = [];
            }

            // Export error log for debugging
            exportErrorLog() {
                const data = {
                    timestamp: Date.now(),
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                    errors: this.errorLog
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `error-log-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }
        }

        // Enhanced Input Validator Class
        class InputValidator {
            constructor(errorHandler) {
                this.errorHandler = errorHandler;
                this.validationRules = new Map();
                this.init();
            }

            init() {
                this.setupFormValidation();
            }

            setupFormValidation() {
                // Add validation to all inputs
                document.addEventListener('DOMContentLoaded', () => {
                    this.bindValidationEvents();
                });

                // If DOM is already loaded
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.bindValidationEvents());
                } else {
                    this.bindValidationEvents();
                }
            }

            bindValidationEvents() {
                // Text input validation
                const textInput = document.getElementById('text-input');
                if (textInput) {
                    this.addValidation(textInput, [
                        'required',
                        { type: 'minLength', param: 1, message: '文本内容不能为空' },
                        { type: 'maxLength', param: 10000, message: '文本内容不能超过10000个字符' }
                    ]);
                }

                // URL input validation
                const urlInput = document.getElementById('url-input');
                if (urlInput) {
                    this.addValidation(urlInput, [
                        'required',
                        'url'
                    ]);
                }

                // Chat input validation
                const chatInput = document.getElementById('chat-input');
                if (chatInput) {
                    this.addValidation(chatInput, [
                        'required',
                        { type: 'maxLength', param: 1000, message: '消息长度不能超过1000个字符' }
                    ]);
                }

                // Token input validation
                const tokenInput = document.getElementById('token-input');
                if (tokenInput) {
                    this.addValidation(tokenInput, [
                        { type: 'minLength', param: 10, message: 'Token长度至少10个字符' }
                    ]);
                }

                // File input validation
                const imageInput = document.getElementById('image-input');
                if (imageInput) {
                    imageInput.addEventListener('change', (e) => {
                        this.validateFileInput(e.target);
                    });
                }
            }

            addValidation(element, rules) {
                this.validationRules.set(element, rules);

                // Real-time validation on input
                element.addEventListener('input', () => {
                    this.validateElement(element);
                });

                // Validation on blur
                element.addEventListener('blur', () => {
                    this.validateElement(element);
                });
            }

            validateElement(element) {
                const rules = this.validationRules.get(element);
                if (!rules) return true;

                const value = element.value.trim();
                const errors = this.errorHandler.validateInput(value, rules, this.getFieldName(element));

                if (errors.length > 0) {
                    element.classList.add('error');
                    this.showFieldError(element, errors[0]);
                    return false;
                } else {
                    element.classList.remove('error');
                    this.clearFieldError(element);
                    return true;
                }
            }

            validateFileInput(fileInput) {
                const file = fileInput.files[0];
                if (!file) return true;

                const maxSize = 10 * 1024 * 1024; // 10MB
                const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

                const errors = [];

                if (!this.errorHandler.validationRules.fileSize(file, maxSize)) {
                    errors.push(this.errorHandler.getValidationMessage('fileSize', '图片', maxSize));
                }

                if (!this.errorHandler.validationRules.fileType(file, allowedTypes)) {
                    errors.push('只支持 JPEG, PNG, GIF, WebP 格式的图片');
                }

                if (errors.length > 0) {
                    this.errorHandler.showValidationErrors(errors, fileInput);
                    fileInput.value = ''; // Clear invalid file
                    return false;
                }

                return true;
            }

            getFieldName(element) {
                const fieldNames = {
                    'text-input': '文本内容',
                    'url-input': 'URL地址',
                    'chat-input': '消息',
                    'token-input': 'Token',
                    'context-input': '上下文',
                    'image-prompt': '图片提示',
                    'image-context': '图片上下文'
                };

                return fieldNames[element.id] || '输入';
            }

            showFieldError(element, message) {
                // Remove existing error message
                this.clearFieldError(element);

                // Create error message element
                const errorDiv = document.createElement('div');
                errorDiv.className = 'field-error';
                errorDiv.style.cssText = `
                    color: #ef4444;
                    font-size: 0.75rem;
                    margin-top: 4px;
                    display: block;
                `;
                errorDiv.textContent = message;
                errorDiv.id = element.id + '-error';

                // Insert after the input element
                element.parentNode.insertBefore(errorDiv, element.nextSibling);
            }

            clearFieldError(element) {
                const errorDiv = document.getElementById(element.id + '-error');
                if (errorDiv) {
                    errorDiv.remove();
                }
            }

            // Validate all form elements
            validateAll() {
                let isValid = true;

                this.validationRules.forEach((rules, element) => {
                    if (!this.validateElement(element)) {
                        isValid = false;
                    }
                });

                return isValid;
            }

            // Clear all validation errors
            clearAllErrors() {
                document.querySelectorAll('.field-error').forEach(error => error.remove());
                document.querySelectorAll('.input.error').forEach(input => input.classList.remove('error'));
            }
        }

        // UI Manager for enhanced interactions and components
        class UIManager {
            constructor() {
                this.toastContainer = null;
                this.loadingOverlay = null;
                this.init();
            }

            init() {
                this.createToastContainer();
                this.createLoadingOverlay();
                this.bindGlobalEvents();
                this.enhanceButtons();
                this.addKeyboardShortcuts();
            }

            createToastContainer() {
                this.toastContainer = document.createElement('div');
                this.toastContainer.id = 'toast-container';
                this.toastContainer.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 10000;
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                    pointer-events: none;
                `;
                document.body.appendChild(this.toastContainer);
            }

            createLoadingOverlay() {
                this.loadingOverlay = document.createElement('div');
                this.loadingOverlay.id = 'loading-overlay';
                this.loadingOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: none;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                `;
                this.loadingOverlay.innerHTML = `
                    <div style="background: white; padding: 24px; border-radius: 8px; text-align: center;">
                        <div class="loading" style="margin: 0 auto 16px;"></div>
                        <div>处理中，请稍候...</div>
                    </div>
                `;
                document.body.appendChild(this.loadingOverlay);
            }

            showToast(message, type = 'info', duration = 5000) {
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.style.cssText = `
                    background: ${this.getToastColor(type)};
                    color: ${this.getToastTextColor(type)};
                    padding: 12px 16px;
                    border-radius: 6px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    max-width: 300px;
                    word-wrap: break-word;
                    pointer-events: auto;
                    cursor: pointer;
                    transform: translateX(100%);
                    transition: transform 0.3s ease;
                    font-size: 0.875rem;
                    border: 1px solid ${this.getToastBorderColor(type)};
                `;
                toast.textContent = message;

                // Add close functionality
                toast.addEventListener('click', () => {
                    this.removeToast(toast);
                });

                this.toastContainer.appendChild(toast);

                // Animate in
                setTimeout(() => {
                    toast.style.transform = 'translateX(0)';
                }, 10);

                // Auto remove
                if (duration > 0) {
                    setTimeout(() => {
                        this.removeToast(toast);
                    }, duration);
                }

                return toast;
            }

            removeToast(toast) {
                if (toast && toast.parentNode) {
                    toast.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }
            }

            getToastColor(type) {
                const colors = {
                    success: '#d1fae5',
                    error: '#fee2e2',
                    warning: '#fef3c7',
                    info: '#dbeafe'
                };
                return colors[type] || colors.info;
            }

            getToastTextColor(type) {
                const colors = {
                    success: '#065f46',
                    error: '#991b1b',
                    warning: '#92400e',
                    info: '#1e40af'
                };
                return colors[type] || colors.info;
            }

            getToastBorderColor(type) {
                const colors = {
                    success: '#a7f3d0',
                    error: '#fca5a5',
                    warning: '#fde68a',
                    info: '#93c5fd'
                };
                return colors[type] || colors.info;
            }

            showLoadingOverlay() {
                this.loadingOverlay.style.display = 'flex';
            }

            hideLoadingOverlay() {
                this.loadingOverlay.style.display = 'none';
            }

            bindGlobalEvents() {
                // Add ripple effect to buttons
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('btn')) {
                        this.createRipple(e);
                    }
                });

                // Add focus effects
                document.addEventListener('focusin', (e) => {
                    if (e.target.classList.contains('input')) {
                        e.target.parentElement?.classList.add('focused');
                    }
                });

                document.addEventListener('focusout', (e) => {
                    if (e.target.classList.contains('input')) {
                        e.target.parentElement?.classList.remove('focused');
                    }
                });
            }

            createRipple(event) {
                const button = event.target;
                const rect = button.getBoundingClientRect();
                const size = Math.max(rect.width, rect.height);
                const x = event.clientX - rect.left - size / 2;
                const y = event.clientY - rect.top - size / 2;

                const ripple = document.createElement('span');
                ripple.style.cssText = `
                    position: absolute;
                    width: ${size}px;
                    height: ${size}px;
                    left: ${x}px;
                    top: ${y}px;
                    background: rgba(255, 255, 255, 0.3);
                    border-radius: 50%;
                    transform: scale(0);
                    animation: ripple 0.6s linear;
                    pointer-events: none;
                `;

                // Ensure button has relative positioning
                if (getComputedStyle(button).position === 'static') {
                    button.style.position = 'relative';
                }
                button.style.overflow = 'hidden';

                button.appendChild(ripple);

                setTimeout(() => {
                    ripple.remove();
                }, 600);
            }

            enhanceButtons() {
                const buttons = document.querySelectorAll('.btn');
                buttons.forEach(button => {
                    // Add hover effects
                    button.addEventListener('mouseenter', () => {
                        if (!button.disabled) {
                            button.style.transform = 'translateY(-1px)';
                            button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.15)';
                        }
                    });

                    button.addEventListener('mouseleave', () => {
                        button.style.transform = 'translateY(0)';
                        button.style.boxShadow = 'none';
                    });

                    // Add active state
                    button.addEventListener('mousedown', () => {
                        if (!button.disabled) {
                            button.style.transform = 'translateY(1px)';
                        }
                    });

                    button.addEventListener('mouseup', () => {
                        if (!button.disabled) {
                            button.style.transform = 'translateY(-1px)';
                        }
                    });
                });
            }

            addKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + Enter for primary actions
                    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                        const activeElement = document.activeElement;

                        if (activeElement.id === 'text-input') {
                            document.getElementById('process-text-btn')?.click();
                        } else if (activeElement.id === 'chat-input') {
                            document.getElementById('send-chat-btn')?.click();
                        } else if (activeElement.id === 'url-input') {
                            document.getElementById('analyze-url-btn')?.click();
                        }
                    }

                    // Escape to clear/cancel
                    if (e.key === 'Escape') {
                        this.hideLoadingOverlay();

                        // Clear focus from inputs
                        if (document.activeElement.classList.contains('input')) {
                            document.activeElement.blur();
                        }
                    }

                    // Alt + C to clear chat
                    if (e.altKey && e.key === 'c') {
                        e.preventDefault();
                        document.getElementById('clear-chat-btn')?.click();
                    }
                });
            }

            // Enhanced result formatter
            formatResult(data, type = 'default') {
                const container = document.createElement('div');
                container.className = 'formatted-result';

                if (typeof data === 'object') {
                    if (type === 'json') {
                        container.innerHTML = this.formatJSON(data);
                    } else if (type === 'text') {
                        container.innerHTML = this.formatText(data);
                    } else {
                        container.innerHTML = this.formatDefault(data);
                    }
                } else {
                    container.textContent = String(data);
                }

                return container;
            }

            formatJSON(data) {
                return `<pre><code>${JSON.stringify(data, null, 2)}</code></pre>`;
            }

            formatText(data) {
                if (data.content || data.text || data.message) {
                    return `<div class="text-content">${data.content || data.text || data.message}</div>`;
                }
                return this.formatJSON(data);
            }

            formatDefault(data) {
                let html = '';

                Object.keys(data).forEach(key => {
                    const value = data[key];
                    html += `<div class="result-item">`;
                    html += `<strong>${key}:</strong> `;

                    if (typeof value === 'object') {
                        html += `<pre>${JSON.stringify(value, null, 2)}</pre>`;
                    } else {
                        html += `<span>${value}</span>`;
                    }

                    html += `</div>`;
                });

                return html;
            }

            // Progress indicator
            showProgress(element, progress = 0) {
                let progressBar = element.querySelector('.progress-bar');

                if (!progressBar) {
                    progressBar = document.createElement('div');
                    progressBar.className = 'progress-bar';
                    progressBar.style.cssText = `
                        position: absolute;
                        bottom: 0;
                        left: 0;
                        height: 2px;
                        background: #2563eb;
                        transition: width 0.3s ease;
                        width: 0%;
                    `;

                    element.style.position = 'relative';
                    element.appendChild(progressBar);
                }

                progressBar.style.width = `${progress}%`;

                if (progress >= 100) {
                    setTimeout(() => {
                        progressBar.remove();
                    }, 300);
                }
            }

            // Smooth scroll to element
            scrollToElement(element, offset = 0) {
                const elementPosition = element.offsetTop - offset;
                window.scrollTo({
                    top: elementPosition,
                    behavior: 'smooth'
                });
            }

            // Copy to clipboard with feedback
            async copyToClipboard(text) {
                try {
                    await navigator.clipboard.writeText(text);
                    this.showToast('已复制到剪贴板', 'success', 2000);
                    return true;
                } catch (error) {
                    this.showToast('复制失败', 'error', 3000);
                    return false;
                }
            }

            // Add copy buttons to result areas
            addCopyButtons() {
                const resultAreas = document.querySelectorAll('.results');
                resultAreas.forEach(area => {
                    if (!area.querySelector('.copy-btn')) {
                        const copyBtn = document.createElement('button');
                        copyBtn.className = 'btn btn-small copy-btn';
                        copyBtn.textContent = '复制';
                        copyBtn.style.cssText = `
                            position: absolute;
                            top: 8px;
                            right: 8px;
                            z-index: 1;
                        `;

                        copyBtn.addEventListener('click', () => {
                            const content = area.querySelector('pre')?.textContent || area.textContent;
                            this.copyToClipboard(content);
                        });

                        area.style.position = 'relative';
                        area.appendChild(copyBtn);
                    }
                });
            }
        }

        // Global instances
        let authManager;
        let apiClient;
        let textProcessor;
        let chatManager;
        let imageProcessor;
        let urlAnalyzer;
        let uiManager;
        let globalErrorHandler;
        let inputValidator;

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function () {
            console.log('BountyGo Multi-Agent Test Page loaded');

            // Initialize global error handler first
            globalErrorHandler = new GlobalErrorHandler();

            // Make it globally available for other components
            window.globalErrorHandler = globalErrorHandler;

            // Initialize input validator
            inputValidator = new InputValidator(globalErrorHandler);

            // Initialize authentication manager
            authManager = new AuthManager();

            // Make auth manager globally available for error handler
            window.authManager = authManager;

            // Initialize API client
            apiClient = new APIClient(authManager);

            // Initialize text processor
            textProcessor = new TextProcessor(apiClient, authManager);

            // Initialize chat manager
            chatManager = new ChatManager(apiClient, authManager);

            // Initialize image processor
            imageProcessor = new ImageProcessor(apiClient, authManager);

            // Initialize URL analyzer
            urlAnalyzer = new URLAnalyzer(apiClient, authManager);

            // Initialize UI manager
            uiManager = new UIManager();

            // Enhance existing message system with toast notifications
            const originalShowMessage = authManager.showMessage;
            authManager.showMessage = function (message, type = 'info') {
                // Show both old and new message systems
                originalShowMessage.call(this, message, type);
                uiManager.showToast(message, type);
            };

            // Integrate error handler with existing components
            enhanceErrorHandling();

            // Add copy buttons to result areas
            setTimeout(() => {
                uiManager.addCopyButtons();
            }, 100);

            // Initialize network monitoring
            initNetworkMonitoring();

            // Add debug commands for development
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                addDebugCommands();
            }

            // Add basic click handlers for other buttons to prevent errors
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                if (!['save-token-btn', 'get-dev-token-btn', 'clear-token-btn', 'process-text-btn', 'send-chat-btn', 'clear-chat-btn', 'analyze-image-btn', 'analyze-url-btn'].includes(button.id)) {
                    button.addEventListener('click', function (e) {
                        console.log('Button clicked:', e.target.id);
                    });
                }
            });
        });

        // Network monitoring
        function initNetworkMonitoring() {
            const networkStatus = document.getElementById('network-status');
            if (!networkStatus) return;

            let isOnline = navigator.onLine;
            let lastResponseTime = Date.now();

            function updateNetworkStatus(status, message) {
                networkStatus.className = `network-status ${status}`;
                networkStatus.innerHTML = `<span>●</span><span>${message}</span>`;
            }

            // Monitor online/offline status
            window.addEventListener('online', () => {
                isOnline = true;
                updateNetworkStatus('online', '网络已连接');
                authManager.showMessage('网络连接已恢复', 'success');
            });

            window.addEventListener('offline', () => {
                isOnline = false;
                updateNetworkStatus('offline', '网络已断开');
                authManager.showMessage('网络连接已断开', 'warning');
            });

            // Monitor API response times
            const originalFetch = window.fetch;
            window.fetch = async (...args) => {
                const startTime = Date.now();

                try {
                    const response = await originalFetch(...args);
                    const responseTime = Date.now() - startTime;
                    lastResponseTime = responseTime;

                    // Update status based on response time
                    if (responseTime > 5000) {
                        updateNetworkStatus('slow', `网络较慢 (${responseTime}ms)`);
                    } else if (isOnline) {
                        updateNetworkStatus('online', '网络正常');
                    }

                    return response;
                } catch (error) {
                    if (isOnline) {
                        updateNetworkStatus('slow', '网络不稳定');
                    }
                    throw error;
                }
            };

            // Initial status
            updateNetworkStatus(isOnline ? 'online' : 'offline', isOnline ? '网络正常' : '网络已断开');
        }

        // Enhance existing components with better error handling
        function enhanceErrorHandling() {
            // Enhance TextProcessor error handling
            const originalTextProcessorHandleError = textProcessor.handleError;
            textProcessor.handleError = function (errorMessage, status = null) {
                const { userMessage, errorType } = globalErrorHandler.handleAPIError(errorMessage, status, '/multi-agent/process');

                // Show error in results area
                const resultsContainer = document.getElementById('text-results');
                const resultsContent = document.getElementById('text-results-content');

                if (resultsContainer && resultsContent) {
                    resultsContent.textContent = `错误: ${errorMessage}`;
                    resultsContainer.classList.remove('hidden');
                }
            };

            // Enhance ChatManager error handling
            const originalChatManagerHandleError = chatManager.handleError;
            chatManager.handleError = function (errorMessage, status = null) {
                const { userMessage, errorType } = globalErrorHandler.handleAPIError(errorMessage, status, '/multi-agent/chat');

                // Add error message to chat
                this.addMessage(`错误: ${userMessage}`, 'assistant');
            };

            // Enhance ImageProcessor error handling
            const originalImageProcessorHandleError = imageProcessor.handleError;
            imageProcessor.handleError = function (errorMessage, status = null) {
                const { userMessage, errorType } = globalErrorHandler.handleAPIError(errorMessage, status, '/multi-agent/image');

                // Show error in results area
                const resultsContainer = document.getElementById('image-results');
                const resultsContent = document.getElementById('image-results-content');

                if (resultsContainer && resultsContent) {
                    resultsContent.textContent = `错误: ${errorMessage}`;
                    resultsContainer.classList.remove('hidden');
                }
            };

            // Enhance URLAnalyzer error handling
            const originalURLAnalyzerHandleError = urlAnalyzer.handleError;
            urlAnalyzer.handleError = function (errorMessage, status = null, url = null) {
                const { userMessage, errorType } = globalErrorHandler.handleAPIError(errorMessage, status, '/multi-agent/url');

                // Show error in results area
                const resultsContainer = document.getElementById('url-results');
                const resultsContent = document.getElementById('url-results-content');
                const urlInput = document.getElementById('url-input');

                if (resultsContainer && resultsContent) {
                    let errorDisplay = `错误: ${errorMessage}`;
                    if (url) {
                        errorDisplay += `\n\n分析的URL: ${url}`;
                    }
                    resultsContent.textContent = errorDisplay;
                    resultsContainer.classList.remove('hidden');
                }

                // Highlight URL input on URL-related errors
                if (status === 400 || status === 404) {
                    if (urlInput) urlInput.classList.add('error');
                }
            };

            // Enhance API client with better error handling
            const originalAPIClientRequest = apiClient.request;
            apiClient.request = async function (endpoint, options = {}) {
                try {
                    // Add timeout handling
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('Request timeout')), options.timeout || 30000);
                    });

                    const requestPromise = originalAPIClientRequest.call(this, endpoint, options);
                    const response = await Promise.race([requestPromise, timeoutPromise]);

                    return response;
                } catch (error) {
                    // Let global error handler process the error
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        globalErrorHandler.handleNetworkError(error, endpoint);
                    }
                    throw error;
                }
            };
        }

        // Add debug commands for development environment
        function addDebugCommands() {
            // Show error statistics section in development
            const errorStatsSection = document.getElementById('error-stats');
            if (errorStatsSection) {
                errorStatsSection.classList.remove('hidden');

                // Bind debug button events
                document.getElementById('show-error-stats-btn')?.addEventListener('click', () => {
                    const stats = globalErrorHandler.getErrorStats();
                    const message = `错误统计:\n总计: ${stats.total}\n类型分布: ${JSON.stringify(stats.byType, null, 2)}`;
                    alert(message);
                });

                document.getElementById('clear-error-log-btn')?.addEventListener('click', () => {
                    globalErrorHandler.clearErrorLog();
                    authManager.showMessage('错误日志已清除', 'info');
                });

                document.getElementById('export-error-log-btn')?.addEventListener('click', () => {
                    globalErrorHandler.exportErrorLog();
                });

                document.getElementById('test-error-btn')?.addEventListener('click', () => {
                    // Test different types of errors
                    const errorTypes = [
                        { message: '这是一个测试错误', type: 'error' },
                        { message: '这是一个测试警告', type: 'warning' },
                        { message: '这是一个测试信息', type: 'info' }
                    ];

                    const randomError = errorTypes[Math.floor(Math.random() * errorTypes.length)];
                    authManager.showMessage(randomError.message, randomError.type);
                });
            }

            // Add global debug functions
            window.debugBountyGo = {
                getErrorStats: () => globalErrorHandler.getErrorStats(),
                clearErrors: () => globalErrorHandler.clearErrorLog(),
                exportErrors: () => globalErrorHandler.exportErrorLog(),
                validateAll: () => inputValidator.validateAll(),
                clearValidationErrors: () => inputValidator.clearAllErrors(),
                testError: (message, type = 'error') => authManager.showMessage(message, type),
                testNetworkError: () => {
                    fetch('/non-existent-endpoint').catch(error => {
                        globalErrorHandler.handleNetworkError(error, '/non-existent-endpoint');
                    });
                },
                simulateAPIError: (status) => {
                    globalErrorHandler.handleAPIError('Simulated API error', status, '/test-endpoint');
                },
                testValidation: () => {
                    const textInput = document.getElementById('text-input');
                    if (textInput) {
                        textInput.value = '';
                        inputValidator.validateElement(textInput);
                    }
                }
            };

            console.log('Debug commands available: window.debugBountyGo');
            console.log('Available commands:', Object.keys(window.debugBountyGo));
        }
    </script>
</body>

</html>